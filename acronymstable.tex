\section*{
\begin{center}
\LARGE \textbf{\textcolor{cyan}{Symbols and Acronyms}}
\end{center}
}
\begin{center}
\begin{longtable}{l p{3.3in}}
%  \caption{Summary of symbols and notations}
	\label{tab:symbols}\\
%  \hline \multicolumn{1}{|c|}{\textbf{symbols and operations}} &
%\multicolumn{1}{c|}{\textbf{description}}  \\ 
\multicolumn{1}{l}{\textbf{Symbols}} &
\multicolumn{1}{l}{\textbf{Definition}}  \\
\endfirsthead


\multicolumn{2}{r}%
{{\textit{ -- continued from previous page}}} \\\\
\multicolumn{1}{l}{\textbf{Acronyms}} &
\multicolumn{1}{l}{\textbf{Description}}  \\
\endhead

\multicolumn{2}{r}{{\textit{continued on next page}}} \\
\endfoot
\endlastfoot

\multicolumn{2}{c}{ }\\  [0.8ex]
$t$ &							Time instant	\\ 
$\tau$ &					Task set	\\
$T_{i}$ &					Individual task indexed as $i$	\\
$T_{i,j}$ &				Individual job $j$ of task $T_{i}$	\\
$J$ &							Job set	\\
$r_{i}$ &					Release time of task $T_{i}$	\\
$C_{i}$ &					Worst-case execution time (WCET) of task $T_{i}$	\\
$d_{i}$ &					Relative deadline of task $T_{i}$	\\
$P_{i}$ &					Period of task $T_{i}$	\\
$O_{i}$ &					Offset of first job $T_{i,1}$ of $T_{i}$ w.r.t. system activation	\\
$L_{i}$ &					Absolute laxity of task $T_{i}$	\\
$l_{i}$ &					Anticipative laxity of task $T_{i}$	\\
$u_{i}$ &					Utilization of individual task $T_{i}$\\
$U_{sum} (\tau)$ &					Utilization of task set $\tau$\\
$\pi_{k}$ &				Individual processor indexed as $k$\\
$\Pi$ &						Processor set/ platform\\
$n$ &							Number of tasks in $\tau$\\
$m$ &							Number of processors in $\Pi$\\
$\nu$ &						Speed of processor $\pi_{k}$\\
$F_{op}$	&				Operating frequency\\
$V_{op}$	&				Operating voltage\\
$V_{th}$	&				Threshold voltage\\
$E$	&							Energy\\
$\epsilon$	&			Dynamic slack\\
$\phi$	&					Scaling factor\\
$Pwr(\nu)$	&				Power as function of speed $\nu$\\
$\tau_{\pi_{k}}$ &	Subset of tasks partitioned on processor $\pi_{k}$\\
$S^{can}$ &				Canonical Schedule of tasks\\
$S^{pra}$ &				Practical Schedule of tasks\\
$DBF(\tau,L)$	&		Demand Bound Function of task set $\tau$ over interval of length $L$\\
$N$	&							Number of Experts (where, expert is any power management scheme)\\
$w$	&							Weight factor for individual expert\\
$W$	&							Weight vector for expert set\\
$h$	&							Probability factor for individual expert\\
$H$	&							Probability vector for expert set\\\\
AET			&					Actual Execution Time\\
AsDPM	&						Assertive Dynamic Power Management\\
ASEDZL	&					Anticipating Slack Earliest Deadline until Zero Laxity\\
BCET			&				Best-case Execution Time\\
BET	&							Break-Even Time\\
ccEDF	&						Cycle-conserving	Earliest Deadline First\\
DeTQ	&						Deferred Tasks Queue\\
DPM		&						Dynamic Power Management\\
DSF		&						Deterministic Stretch-to-Fit\\
DSR	&							Dynamic Slack Reclamation\\
DVFS	&						Dynamic Voltage and Frequency Scaling\\
EDF	&							Earliest Deadline First\\
EDZL &						Earliest Deadline until Zero Laxity\\
HyPowMan	&				Hybrid Power Management\\
LLF		&						Least Laxity First\\
LLREF		&					Least Local Remaining Execution First\\
m-TE	&						m-Task Extension\\
OSM	&							Online Speculative speed adjustment Mechanism\\
PFair	&						Proportionate Fairness\\
ReTQ	&						Ready Tasks Queue\\
RM	&							Rate Monotonic\\
RuTQ	&						Running Tasks Queue\\
SMP	&							Symmetric shared-memory Multiprocessor\\
TQ	&							Tasks Queue\\
WCET			&				Worst-case Execution Time\\
2L-HiSA	&					Two-level Hierarchical Scheduling Algorithm\\\\ \hline










%$\mathcal{A}$ &   Set of processes(activities): $\alpha,\beta..\in\mathcal{A}$ \\
%$\mathcal{F}$ &   Set of futures   \\
%    \multirow
%        {2}{*}{$f^{\alpha \to \beta }$} & Future $f$ created as a result of an asynchronous \\
%         &  method call  by  process $\alpha$ on process $\beta$. $\beta$ will \\
%         & compute the future value. \\  
%    \multirow
%        {2}{*} {$\mathcal{FL}_{\alpha}$} & Future list at process
%$\alpha$. Keeps track of   all
%     referenced  futures  for this process. \\ \hline
%   \multirow
%        {2}{*}{$\mathcal{FR}_{\delta }$} &  List of future recipients at
%        process $\delta$. Keeps track of   all the processes to which a
%        result should be sent when available.  \\ \hline
%  \multirow
%        {2}{*}{$\symb{Reg}_{\delta }$} & Register future operation at
%        process $\delta$. Adds <future, process/location> in $\mathcal{FL}$
%        or $\mathcal{FR}$. \\ \hline
%
%  \multirow
%        {2}{*}{$\symb{Update}_{\delta }(loc,v)$} & Future update
%operation at
%        process $\delta$. Locally updates all occurrences of a given future
%        (at memory position $loc$) with the
%        result value $v$. \\ \hline
%  \multirow
%        {2}{*}{$\symb{Clear}_{\delta }(f^{\alpha \to \beta },L)$} &
%Remove future
%        operation. Removes all occurrences of a future $f^{\alpha \to
%\beta }$ from the list
%        L (either $\mathcal{FL_{\delta}}$ or $\mathcal{FR_{\delta}})$.
%\\ \hline
%\multirow
%        {2}{*}{$\symb{SendValue}_{\delta\to \gamma }(f^{\alpha \to \beta
%},v)$} & Transmit
%        future value operation. Sends the result value $v$ corresponding to
%        future $f^{\alpha \to \beta }$, from process $\delta$ to process
%$\gamma$. The value
%        $v$ may also contain futures.\\ \hline
%\multirow
%        {2}{*}{$\symb{Create}_{\alpha }(f^{\alpha \to \beta },loc)$} &  
%Create a new
%        future operation. Creates the result value $v$ corresponding to
%        future $f^{\alpha \to \beta }$, from process $\delta$ to process
%$\gamma$. \\ \hline
%
%\multirow
%        {2}{*}{$\symb{SendRef}_{\delta \to \gamma }(f^{\alpha \to \beta
%},loc)$} &  Future
%        forwarding operation. Communicates a future $f^{\alpha \to \beta
%}$, from process $\delta$ to process $\gamma$. \\ \hline
%\multirow
%        {2}{*}{$\symb{FutureComputed}_{\beta }(f^{\alpha \to \beta
%},v)$} & Request
%        execution termination operation . Occurs when the execution of
%        a request corresponding to future$f^{\alpha \to \beta }$ is
%completed and
%        a result value $v$ is produced. $v$ may contain other futures.
%\\ \hline
%\multirow
%        {2}{*}{$\symb{Wait}_{\alpha }$} & Access to an unresolved
%future. This
%        event occurs when a process attempts to access the value of an
%        unresolved future. The accessing execution thread is blocked
%        until the result arrives. \\ \hline
%\multicolumn{2}{|c|}{\bf Chapter-4}\\ [0.8ex] \hline
%
%\multirow
%        {2}{*}{\texttt{newActive(\ldots)}} & Method for creating a new
%        active object. Requires the {\it class} of the object. \\ \hline
%
%\multirow
%        {2}{*}{\texttt{turnActive(\ldots)}} & Method for turning a normal
%        java object into an active object. \\ \hline
%
%\multirow
%        {2}{*}{\texttt{FuturePool}} & Class in ProActive which keeps
%        track of futures. Provides the functionality of $\mathcal{FR}$,
%$\mathcal{FL}$
%        list in semi-formal specification. \\ \hline
%
%\multirow
%        {2}{*}{\texttt{FutureMap}} &  Class in ProActive which
%        implements a mapping between a future and its corresponding
%        automatic continuation (mechanism for updating the results of
%        first class futures). \\ \hline
%\multirow
%        {2}{*}{\texttt{ActiveACQueue}} &  A thread inside an active
%        object for communicating future values.  \\ \hline
%\multirow
%        {2}{*}{\texttt{RequestForFutures}} & A registration message for
%        adding processes as future recipients. Used in message-based
%strategies.\\ \hline
%\multicolumn{2}{|c|}{\bf Chapter-5}\\  [0.8ex]\hline
%\multicolumn{2}{|c|}{Isabelle/HOL Syntax and Notation} \\  [0.8ex]\hline
%
%\multirow
%        {2}{*}{\texttt{HOL}} & A theory in Isabelle/HOL theorem prover,
%        encoding the higher order logic.\\ \hline
%
%  $(a_1,a_2)$ & Pairs with the datatype $(\tau_1 \times \tau_2)$, where
%$a_1$has
%  type $\tau_1$ and $a_2$ has type $\tau_2$.\\ \hline



\end{longtable}
\end{center}